<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Const Generics Project Group</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="skill-tree.css">
        <link rel="stylesheet" href="skill-tree-finetuning.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html">👋🏽 Welcome</a></li><li class="chapter-item expanded "><a href="CHARTER.html">📜 Charter</a></li><li class="chapter-item expanded "><a href="vision.html">🔮 The vision</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vision/why-compile-time-evaluation.html">🤔 Why compile time evaluation</a></li><li class="chapter-item expanded "><a href="vision/characters.html">🙋‍♀️ Cast of characters</a></li><li class="chapter-item expanded "><a href="skill-tree.html">🔀 Skill Tree</a></li><li class="chapter-item expanded "><a href="vision/status_quo.html">😱 Status quo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vision/status_quo/array_default.html">Array defaults</a></li><li class="chapter-item expanded "><a href="vision/status_quo/split_first.html">Array split first method</a></li><li class="chapter-item expanded "><a href="vision/status_quo/nalgebra.html">nalgebra</a></li></ol></li><li class="chapter-item expanded "><a href="vision/shiny_future.html">✨ Shiny future</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vision/shiny_future/array_default.html">Array defaults</a></li><li class="chapter-item expanded "><a href="vision/shiny_future/split_first.html">Array split first method</a></li><li class="chapter-item expanded "><a href="vision/shiny_future/image_type.html">Image type in rust-gpu</a></li></ol></li><li class="chapter-item expanded "><a href="vision/roadmap.html">📅 Roadmap for 2021</a></li><li class="chapter-item expanded "><a href="vision/how_to_vision_doc.html">❓How to vision doc</a></li></ol></li><li class="chapter-item expanded "><a href="meetings/index.html">🔍 Meetings</a></li><li class="chapter-item expanded "><a href="design/index.html">📚 Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/constraining-generic-parameters.html">❗ Constraining generic parameters</a></li><li class="chapter-item expanded "><a href="design/generic-const-param-types.html">❗⚖️🔄 Generic const parameter types</a></li><li class="chapter-item expanded "><a href="design/leaking-implementation-details.html">❗🔙 Leaking implementation details</a></li><li class="chapter-item expanded "><a href="design/opaque-and-transparent-assoc-consts.html">❗🔙 Opaque and transparent associated constants</a></li><li class="chapter-item expanded "><a href="design/const-eval-requirements.html">❗🔙 Restrictions on const evaluation</a></li><li class="chapter-item expanded "><a href="design/eval-errors-during-selection.html">❗🔄 Silence evaluation errors during selection</a></li><li class="chapter-item expanded "><a href="design/structural-equality.html">❗🔙 ⚖️ Structural equality</a></li><li class="chapter-item expanded "><a href="design/unused-substs.html">❗🔙 🔄 Unused substs</a></li><li class="chapter-item expanded "><a href="design/valid-const-parameter-types.html">❗⚖️ Valid const parameter types</a></li><li class="chapter-item expanded "><a href="design/valtrees.html">❗ Valtrees</a></li><li class="chapter-item expanded "><a href="design/exhaustiveness.html">❔ Exhaustiveness</a></li><li class="chapter-item expanded "><a href="design/functions-as-const-parameters.html">❔🔙 Functions as const parameters</a></li></ol></li><li class="chapter-item expanded "><a href="draft-rfcs/index.html">✏️ Draft RFCs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Const Generics Project Group</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/project-const-generics" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-const-generics-project-group"><a class="header" href="#-const-generics-project-group">👋🏽 Const Generics Project Group</a></h1>
<!--
 Status badge advertising the project as being actively worked on. When the
 project has finished be sure to replace the active badge with a badge
 like: https://img.shields.io/badge/status-archived-grey.svg
-->
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="project group status: active" /></p>
<!--
FIXME(website)
[![project group documentation](https://img.shields.io/badge/MDBook-View%20Documentation-blue)][gh-pages]
-->
<p>The const generics project group implements and designs the <code>const_generics</code> feature. Please refer to our <a href="./CHARTER.html">charter</a> for more information on our goals and current scope.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;const N: usize&gt; {
    field: [u8; N],
}

fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; {
    Foo {
        field: [0; N],
    }
}

fn main() {
    match foo::&lt;3&gt;().field {
        [0, 0, 0] =&gt; {} // ok
        [_x, _y, _z] =&gt; panic!(),
    }
}
</code></pre></pre>
<p>Welcome to the repository for the Const Generics Project Group! This is the
repository we use to organise our work. Please refer to our <a href="./CHARTER.html">charter</a> as well
as our <a href="https://rust-lang.github.io/project-const-generics">github pages website</a> for more information on our goals and
current scope.</p>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<p><a href="https://github.com/rust-lang/team/blob/master/teams/project-const-generics.toml">You can find a list of the current members available
on <code>rust-lang/team</code>.</a></p>
<p>If you'd like to participate be sure to check out the relevant stream on <a href="https://rust-lang.zulipchat.com/#narrow/stream/260443-project-const-generics">zulip</a>, feel free to introduce
yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook-skill-tree install &amp;&amp; mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--const-generics-charter"><a class="header" href="#--const-generics-charter">📜  Const Generics Charter</a></h1>
<p>The goal of this group is to both improve and extend the support for const generics.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>Improving the user experience when using and working on const generics. This includes both improvements to diagnostics for the already stabilized parts as well as adding new features:</p>
<ul>
<li>const param defaults <code>struct Foo&lt;const N: usize = 3&gt;</code></li>
<li>more const param types, most importantly user defined types and <code>&amp;'static str</code></li>
<li>allowing complex generic operations in constants</li>
</ul>
<h2 id="constraints-and-considerations"><a class="header" href="#constraints-and-considerations">Constraints And Considerations</a></h2>
<p>At least for the near future, we will mostly focus on the items mentioned above.</p>
<!-- Why not just do everything, it's not like burnout is a problem in open source -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="-the-vision"><a class="header" href="#-the-vision">🔮 The vision</a></h1>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this</a></h2>
<p>This section lays out a general vision and set of goals for Const Generics in Rust. </p>
<h2 id="status-and-schedule"><a class="header" href="#status-and-schedule">Status and schedule</a></h2>
<p><strong>This document is currently being formed.</strong> </p>
<h2 id="this-is-a-group-effort"><a class="header" href="#this-is-a-group-effort">This is a group effort</a></h2>
<p>As the leads of the Const Generics group, Niko and lcnr are driving and organizing this document. But writing it and shaping it is a group effort. If you think there is a part of the const generics experience that is not reflected here, we want to hear from you! Check out the <a href="./vision/how_to_vision_doc.html">How to vision doc</a> for more details on how to contribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-compile-time-evaluation"><a class="header" href="#why-compile-time-evaluation">Why compile time evaluation?</a></h1>
<p>This section is, in many ways, the most important. It aims to clarify the reasoning about any future decisions about const generics and const evaluation.</p>
<h2 id="why-do-we-want-to-evaluate-things-at-compile-time"><a class="header" href="#why-do-we-want-to-evaluate-things-at-compile-time">Why do we want to evaluate things at compile time?</a></h2>
<p>People already precompute certain data structures, lookup tables, and so on, at compile time.
For example the crate <code>regex</code> could be able to compile a regex at compile time,
improving the performance when using <code>regex</code> and even removing the need for runtime allocations.
Const evaluation is also very useful to assert correctness requirements at compile time, instead
of using a runtime panic.</p>
<p>Without good const evaluation support, is often easier to just use a <code>build.rs</code> file for this or compute it externally and generate the result outside of the ordinary compilation process. This is both worse for the user, as they essentially have to learn yet another
meta language, and also negatively impacts the compilation speed and incremental compilation. If that isn't possible or sensible, one often just requires the computation to happen at runtime, negatively impacting startup performance.</p>
<p>Computing things outside without using const eval makes it at lot more cumbersome to use and
prevents the input for that computation to simply be a generic or function parameter.</p>
<h2 id="why-const-generics"><a class="header" href="#why-const-generics">Why const generics?</a></h2>
<p>Const evaluation by itself is good enough unless it should influence the type system. </p>
<p>This is needed when computing the layout of types, most often by using arrays.
Using arrays instead of dynamic allocations or slices can improve performance, reduces the dynamic memory footprint
and can remove runtime checks and implicit invariants.</p>
<p>Another reason is to be generic over configurations or to move certain conditions to compile time. Consider <a href="https://github.com/EmbarkStudios/rust-gpu/blob/1431c18b9db70feafc64e5096a64e5fefffbed18/crates/spirv-std/src/image.rs#L31">image handles</a> in <a href="https://github.com/EmbarkStudios/rust-gpu"><code>rust-gpu</code></a> or TODO: example for state machines.</p>
<h2 id="what-are-our-goals"><a class="header" href="#what-are-our-goals">What are our goals?</a></h2>
<h3 id="consistent-just-add-const"><a class="header" href="#consistent-just-add-const">Consistent: &quot;just add <code>const</code>&quot;</a></h3>
<p>Writing code that works at compile time should at most require manually adding the needed <code>const</code> annotations at suggested places (or even automatically using <code>rustfix</code> or IDE support)
until everything compiles. One should not be required to avoid large parts of the language to do this.
Adding and using const parameters should be straight forward without weird restrictions or a lot required knowledge.
Using const generic items from different libraries should work without issues.</p>
<h3 id="approachable-what-is-u8-my_expr-and-why-is-it-needed"><a class="header" href="#approachable-what-is-u8-my_expr-and-why-is-it-needed">Approachable: &quot;what is <code>[u8; my_expr]:,</code> and why is it needed&quot;</a></h3>
<p>Reading or writing code which can be used at compile time should ideally not be more complex
than writing other code. Requiring a lot of weird trait bounds or other hacks should be avoided as much as possible.
Supporting compile time evaluation should not worsen the experience of users, especially for beginners.</p>
<h3 id="reliable-if-it-passes-cargo-check-it-works"><a class="header" href="#reliable-if-it-passes-cargo-check-it-works">Reliable: &quot;if it passes <code>cargo check</code>, it works&quot;</a></h3>
<p>Const evaluation failures should be detected as early as possible, even when using <code>cargo check</code>. When writing library code, incorrect constants
should cause warnings and errors whenever possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-cast-of-characters"><a class="header" href="#-cast-of-characters">🙋‍♀️ Cast of characters</a></h1>
<h2 id="what-is-this-1"><a class="header" href="#what-is-this-1">What is this?</a></h2>
<p>We've created four characters that we use to guide our thinking. These characters are the protagonists of our <a href="vision/./status_quo.html">status quo</a> and <a href="vision/./shiny_future.html">shiny future</a> stories, and they help us to think about the different kinds of priorities and expectations that people bring when using Const Generics in rust. Having names and personalities also makes the stories more fun and approachable.</p>
<h2 id="the-characters"><a class="header" href="#the-characters">The characters</a></h2>
<ul>
<li>Alan: the experienced &quot;GC'd language&quot; developer, new to Rust
<ul>
<li><em>Top priority</em>: performance -- that's what he is not getting from current GC'd language</li>
<li><em>Expectations</em>: absence of memory safety bugs (he gets that now from his GC), strong ecosystem, great tooling</li>
</ul>
</li>
<li>Grace: the systems programming expert, new to Rust
<ul>
<li><em>Top priority</em>: memory safety -- that's what she is not getting from C/C++</li>
<li><em>Expectations</em>: able to do all the things she's used to from C/C++</li>
</ul>
</li>
<li>Niklaus: new programmer from an unconventional background
<ul>
<li><em>Top priority</em>: accessibility -- he's learning a lot of new things at once</li>
<li><em>Expectations</em>: community -- the community enabled him to have early success, and he is excited to have it support him and him grow more</li>
</ul>
</li>
<li>Barbara: the experienced Rust developer
<ul>
<li><em>Top priority</em>: overall productivity and long-term maintenance -- she loves Rust, and wants to see it extended to new areas; she has an existing code base to maintain</li>
<li><em>Expectations</em>: elegance and craftsmanship, fits well with Rust</li>
</ul>
</li>
</ul>
<h2 id="-frequently-asked-questions"><a class="header" href="#-frequently-asked-questions">🤔 Frequently Asked Questions</a></h2>
<h3 id="where-do-the-names-come-from"><a class="header" href="#where-do-the-names-come-from">Where do the names come from?</a></h3>
<p>Famous programming language designers and theorists. <a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>, <a href="https://en.wikipedia.org/wiki/Grace_Hopper">Grace Hopper</a>, <a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>, and <a href="https://en.wikipedia.org/wiki/Barbara_Liskov">Barbara Liskov</a>.</p>
<h3 id="i-dont-see-myself-in-these-characters-what-should-i-do"><a class="header" href="#i-dont-see-myself-in-these-characters-what-should-i-do">I don't see myself in these characters. What should I do?</a></h3>
<p>Come to Zulip (#project-const-generics) and talk to us about it! Maybe they need to be adjusted!</p>
<h3 id="i-see-myself-in-more-than-one-of-these-characters"><a class="header" href="#i-see-myself-in-more-than-one-of-these-characters">I see myself in more than one of these characters!</a></h3>
<p>Yeah, me too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skill-tree-for-const-generics-features"><a class="header" href="#skill-tree-for-const-generics-features">Skill tree for const generics features</a></h1>
<div id='skill-tree-0'></div>
<script>
                    if (!window.SKILL_TREES) window.SKILL_TREES = [];
                    window.SKILL_TREES.push({id:'skill-tree-0', value:{"dot_text":"digraph g {\ngraph [ rankdir = \"LR\" ];\nnode [ fontsize=\"16\", shape = \"ellipse\" ];\nedge [ ];\n\"min_cg\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\" href=\"https://github.com/rust-lang/rust/pull/79135\">MIN CONST GENERICS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\" href=\"https://github.com/rust-lang/rust/pull/79135\">Minimum subset of const generics only allowing `const N: {integer} | bool | char` and fully concrete constants</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"valtree\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">VALTREES</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Use valtrees in all type level constants</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Design of structural equality is worked out</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Valtrees are implemented</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"min_defaults\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">CONCRETE CONST DEFAULTS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Permit concrete defaults on traits/adts</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"generic_defaults\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">GENERIC CONST DEFAULTS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Permit generic defaults on traits/adts</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Disallow usage of forward declared params via param env</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Decide when a generic default is considered well formed</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"param_tys\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">MORE CONST PARAM TYPES</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Permit more types to be as the type of a const generic</td></tr>\n    <tr><td bgcolor=\"cornsilk\">A `Constable` that that signifies a type is valid to use as a const param type</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Generic const param types i.e. `T: Constable, const N: T`</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Consider `impl&lt;const N: usize&gt; Trait&lt;{ Some(N) }&gt; for ()` to constrain `N`</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"exhaustiveness\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">IMPL EXHAUSTIVENESS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Allow separate impls to be used to fulfill `for&lt;const N: usize&gt; (): Trait&lt;N&gt;`</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"min_generic_consts\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">MIN GENERIC CONSTANTS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Allow type level constants to be generic i.e. `N + 1`</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Add a where clause that requires a given expression to be evaluatable e.g. `where evaluatable { N - 1 }`</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Unused substs make it hard to tell if a const is concrete or generic and breaks unsize coercion in some cases</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Don't eagerly error when evaluating constants during selection</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"generic_consts\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">GENERIC CONSTANTS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Allow type level constants but better ✨</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Allow writing a where clause that requires a condition to hold e.g. `where { N &gt; 2 }`</td></tr>\n    <tr><td bgcolor=\"cornsilk\">Some things can always evaluate and should not need a where clause e.g. `{ N == M }` `{ N / 1 }`</td></tr>\n    <tr><td bgcolor=\"cornsilk\">If possible `where { N &gt; 0 }` should imply `N - 1` is evaluatable</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"assoc_const_bounds\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\">ASSOCIATED CONST BOUNDS</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\">Permit where `where T: Trait&lt;ASSOC = 10&gt;`</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"arg_infer\" [\n  label = <<table>\n    <tr><td bgcolor=\"darkgoldenrod\" colspan=\"1\" href=\"https://github.com/rust-lang/rust/pull/83484\">GENERIC ARG CONST INFER</td></tr>\n    <tr><td bgcolor=\"darkgoldenrod1\" colspan=\"1\" href=\"https://github.com/rust-lang/rust/pull/83484\">Permit using `_` for generic args</td></tr>\n  </table>>\n  shape = \"none\"\n  margin = 0\n]\n\"min_defaults\" -> \"min_cg\";\n\"generic_defaults\" -> \"min_defaults\";\n\"param_tys\" -> \"valtree\";\n\"param_tys\" -> \"min_cg\";\n\"exhaustiveness\" -> \"param_tys\";\n\"min_generic_consts\" -> \"min_cg\";\n\"generic_consts\" -> \"min_generic_consts\";\n\"assoc_const_bounds\" -> \"min_generic_consts\";\n\"arg_infer\" -> \"min_cg\";\n}\n","error":""}});
                    </script><div style="break-before: page; page-break-before: always;"></div><h1 id="-status-quo-stories"><a class="header" href="#-status-quo-stories">😱 Status quo stories</a></h1>
<h2 id="what-is-this-2"><a class="header" href="#what-is-this-2">What is this</a></h2>
<p>The &quot;status quo&quot; stores are here to state our &quot;theory of the case&quot;. That is, they present (and prove) our hypotheses as to what the various challenges are for users of Const Generics in Rust. These hypotheses are presented in narrative form, by telling the story of a specific <a href="vision/./characters.html">character</a> as they try (and typically fail in dramatic fashion) to achieve their goals.</p>
<h3 id="based-on-a-true-story"><a class="header" href="#based-on-a-true-story">Based on a true story</a></h3>
<p>These stories are not made up. They are always based on real-life experiences of actual people. Each story contains a &quot;Frequently Asked Questions&quot; section, and that will include notes the sources used to create the story. In some cases, it may link to notes or summaries in the <a href="vision/../conversations.html">conversations</a> section, though that is not required. The &quot;Frequently Asked Questions&quot; section also contains a summary of what the &quot;morals&quot; of the story are (i.e., what are the key takeaways), along with answers to questions that people have raised along the way.</p>
<h3 id="the-stories-provide-data-we-use-to-prioritize-not-a-prioritization-itself"><a class="header" href="#the-stories-provide-data-we-use-to-prioritize-not-a-prioritization-itself">The stories provide data we use to prioritize, not a prioritization itself</a></h3>
<p><strong>Just because a user story is represented here doesn't mean we're going to be able to fix it right now.</strong> Some of these user stories will indicate more severe problems than others. As we consider the stories, we'll select some subset to try and address; that choice is reflected in the <a href="vision/./roadmap.html">roadmap</a>.</p>
<h3 id="help-wanted"><a class="header" href="#help-wanted">Help wanted!</a></h3>
<p>This is not a static document! There are lots of ways you can help to expand it! Take a look at the <a href="vision/./how_to_vision_doc.html">How to Vision Doc</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-status-quo-story-barbara-wants-to-implement-default-for-all-array-lengths"><a class="header" href="#-status-quo-story-barbara-wants-to-implement-default-for-all-array-lengths">😱 Status quo story: Barbara wants to implement <code>Default</code> for all array lengths</a></h1>
<p>Barbara is working on <code>std</code>. She wants to implement <code>Default</code> for all array types. Currently, it is implemented for <code>N &lt;= 32</code> using a macro (<a href="https://doc.rust-lang.org/nightly/src/core/array/mod.rs.html#391">link</a>)</p>
<p>She thinks &quot;Ah, I can use min-const-generics for this!&quot; and goes to write</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; Default for [T; N]
where
    T: Default,
{
    fn default() -&gt; Self {
        
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>So far so good, but then she realizes she can't figure out what to write in the body. At first she tries:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; Default for [T; N]
where
    T: Default,
{
    fn default() -&gt; Self {
        [T::default(); N]
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>but this won't compile:</p>
<pre><code>error[E0277]: the trait bound `T: Copy` is not satisfied
  --&gt; src/lib.rs:10:9
   |
10 |         [T::default(); N]
   |         ^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`
   |
   = note: the `Copy` trait is required because the repeated element will be copied
help: consider further restricting this bound
   |
7  |     T: MyDefault + Copy,
   |                  ^^^^^^
</code></pre>
<p>&quot;Ah,&quot; she realizes, &quot;this would be cloning a single value of <code>T</code>, but I want to make <code>N</code> distinct values. How can I do that?&quot;</p>
<p>She asks on Zulip and lcnr tells her that there is this <a href="https://doc.rust-lang.org/std/primitive.array.html#method.map"><code>map</code> function  defined on arrays</a>. She could write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; Default for [T; N]
where
    T: Default,
{
    fn default() -&gt; Self {
        [(); N].map(|()| T::default())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>&quot;That code will build,&quot; lcnr warns her, &quot;but we're not going to be able to ship it. Test it and see.&quot; Barbara runs the tests and finds she is getting a failure. The following test no longer builds:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;() -&gt; [T; 0] {
    Default::default()
}
<span class="boring">}
</span></code></pre></pre>
<p>&quot;Ah,&quot; she says, &quot;I see that <code>Default</code> is implemented for any type <code>[T; 0]</code>, regardless of whether <code>T: Default</code>. That makes sense. Argh!&quot;</p>
<p>Next she tries (this already relies on a nightly feature)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Trait, const N: usize&gt; Default for [T; N]
where
    T: Default,
    N != 0, // nightly feature!
{
    fn default() -&gt; Self {
        [(); N].map(|()| T::default())
    }
}

impl&lt;T&gt; Trait for [T; 0] {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>While this does seem to compile, when trying to use it, it causes an unexpected error.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Trait, const N: usize&gt;() -&gt; [u8; N] {
    &lt;[T; N] as Trait&gt;::ASSOC //~ ERROR `[T; N]` does not implement `Trait`
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler can't tell that <code>N == 0 || N != 0</code> is true for all possible <code>N</code>, so it can't infer <code>[T; N]: Trait</code> from <code>T: Trait</code>.</p>
<p>Frustrated, Barbara gives up and goes looking for another issue to fix.</p>
<p>Even worse, Barbara notices the same problem for <code>serde::Deserialize</code> and decides to
abandon backwards compatibility in favor of a brighter future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-status-quo-array-split-first-method"><a class="header" href="#-status-quo-array-split-first-method">😱 Status quo: Array split first method</a></h1>
<p>Barbara is working on her project. She has the idea to write a <code>split_first</code> function that will allow her to split out the first item from a fixed-length array; naturally, the array must be non-empty. It looks something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: this method has an implied where clause that `N - 1` evaluates without 
// erroring because `N - 1` is in the function signature
fn split_first&lt;T, const N: usize&gt;(arr: [T; N]) -&gt; (T; [T; N - 1]) {
    // ...
    let tail: [T; N - 1] = // ...
    (head, tail)
}
<span class="boring">}
</span></code></pre></pre>
<p>Next she wants to write a function that uses <code>split_first</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_method&lt;const N: usize&gt;(arr: [u8; N]) {
    let (first, rest) = split_first(arr);
    for i in rest {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler gives her a compile error:</p>
<pre><code>error: the constant expression `N-1` is not known to be evaluatable
2 |     let (first, rest) = split_first(arr);
  |                         ^^^^^^^^^^^ `N-1` not known to be evaluatable
info: N may underflow
help: add a where clause to `some_method`
  | fn some_method&lt;const N: usize&gt;(arr: [u8; N]) where [(); {N - 1}]:
</code></pre>
<p>Barbara hits the 'quick fix' button in her IDE and it inserts the where clause for her- she immediately
gets a compile error at another spot because she was calling <code>some_method</code> with an empty array:</p>
<pre><code>error: integer underflow evaluating constant expression
22 |     some_method([])
   |     ^^^^^^^^^^^^^^^ `0-1` is not evaluatable
info: `0-1` must be evaluatable because of this where clause
  | fn some_method&lt;const N: usize&gt;(arr: [u8; N]) where [(); { N - 1}]:
  |                                                    ---------------
</code></pre>
<p>She also gets a compile error at another spot with a <code>[(); { N - 2; }]:</code> where clause in scope</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_other_method&lt;const N: usize&gt;(arr: [u8; N]) where [(); { N - 2; }]: {
    // ...
    let (first, rest) = split_first(arr);
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>error: the constant expression `N-1` is not known to be evaluatable
2 |     let (first, rest) = split_first(arr);
  |                         ^^^^^^^^^^^ `N-1` not known to be evaluatable
info: N may underflow
help: add a where clause to `some_method`
  | fn some_method&lt;const N: usize&gt;(arr: [u8; N]) where [(); { N - 2; }}:, [(); { N - 1; }];, {
</code></pre>
<p>&quot;What!!! That's silly&quot;- Barbara sighs, hitting the quick fix button and moving on</p>
<p>(rustc is not currently smart enough to know that <code>N - 2</code> being evaluatable implies <code>N - 1</code>)</p>
<h2 id="alt-universe-with-post-mono-errors"><a class="header" href="#alt-universe-with-post-mono-errors">Alt Universe with post-mono errors</a></h2>
<p>Barbara is working on her project. She has the idea to write a <code>split_first</code> function that will allow her to split out the first item from a fixed-length array; naturally, the array must be non-empty. It looks something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: this method has no implied where clause that `N - 1` evaluates
fn split_first&lt;T, const N: usize&gt;(arr: [T; N]) -&gt; (T; [T; N - 1]) {
    // ...
    let tail: [T; N - 1] = // ...
    (head, tail)
}
<span class="boring">}
</span></code></pre></pre>
<p>Next she wants to write a function that uses <code>split_first</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_method&lt;const N: usize&gt;(arr: [u8; N]) {
    let (first, rest) = split_first(arr);
    for i in rest {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Everything seems fine when she runs <code>cargo check</code>. Then later she runs <code>cargo test</code> and sees a compilation error:</p>
<pre><code>error: const evaluation error occurred
22 |    let tail: [T; N - 1] = // ...
   |                  ^^^^^ integer underflow, cannot subtract `1` from `0`
info: this const evaluation was required by `some_other_method`, which contains:
22 |     some_method([])
info: `some_method` contains:
22 |    let (first, rest) = split_first(arr);
info: `split_first` contains:
22 |    let tail: [T; N - 1] = // ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-status-quo-nalgebra"><a class="header" href="#-status-quo-nalgebra">😱 Status quo: nalgebra</a></h1>
<p><em>a huge thanks to <a href="https://github.com/Andlon">Andreas Borgen Longva</a> and <a href="https://github.com/sebcrozet">Sébastien Crozet</a> for the help with figuring this out</em></p>
<p><a href="https://nalgebra.org/">nalgebra</a> is a linear algebra library. At the core of that library is a type <code>struct Matrix&lt;T, R, C, S&gt;</code> where <code>T</code> is the components scalar type, <code>R</code> and <code>C</code> represents the number of rows and columns and <code>S</code> represents the type of the buffer containing the data.</p>
<p>Relevant for const generics are the parameters <code>R</code> and <code>C</code>. These are instantiated using one of the following types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For matrices of know size.
pub struct Const&lt;const R: usize&gt;;
// For matrices with a size only known at runtime.
pub struct Dynamic { value: usize }
<span class="boring">}
</span></code></pre></pre>
<p>The authors of nalgebra then introduce a type alias</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArrayStorage&lt;T, const R: usize, const C: usize&gt;(pub [[T; R]; C]);
/// A matrix of statically know size.
pub type SMatrix&lt;T, const R: usize, const C: usize&gt; =
    Matrix&lt;T, Const&lt;R&gt;, Const&lt;C&gt;, ArrayStorage&lt;T, R, C&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>To deal with the lack of generic const expressions, they add a trait for conversions from and to <a href="https://crates.io/crates/typenum"><code>typenum</code></a> for all <code>Const</code> up to size <code>127</code> (<a href="https://github.com/dimforge/nalgebra/blob/39bb572557299a44093ea09daaff144fd6d9ea1f/src/base/dimension.rs#L273-L345">source</a>).</p>
<p>Whenever they now need some computation using <code>Const&lt;N&gt;</code>, they convert it to type nums, evaluate the computation using the trait system, and then convert the result back to some <code>Const&lt;M&gt;</code>.</p>
<h2 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h2>
<p>While this mostly works fine, there are some disadvantages.</p>
<h3 id="annoying-totypenum-bounds"><a class="header" href="#annoying-totypenum-bounds">Annoying <code>ToTypenum</code> bounds</a></h3>
<p>Most notably this adds a lot of unnecessary bounds, consider the following impl:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const R1: usize, const C1: usize, const R2: usize, const C2: usize&gt;
    ReshapableStorage&lt;T, Const&lt;R1&gt;, Const&lt;C1&gt;, Const&lt;R2&gt;, Const&lt;C2&gt;&gt; for ArrayStorage&lt;T, R1, C1&gt;
where
    T: Scalar,
    Const&lt;R1&gt;: ToTypenum,
    Const&lt;C1&gt;: ToTypenum,
    Const&lt;R2&gt;: ToTypenum,
    Const&lt;C2&gt;: ToTypenum,
    &lt;Const&lt;R1&gt; as ToTypenum&gt;::Typenum: Mul&lt;&lt;Const&lt;C1&gt; as ToTypenum&gt;::Typenum&gt;,
    &lt;Const&lt;R2&gt; as ToTypenum&gt;::Typenum: Mul&lt;
        &lt;Const&lt;C2&gt; as ToTypenum&gt;::Typenum,
        Output = typenum::Prod&lt;
            &lt;Const&lt;R1&gt; as ToTypenum&gt;::Typenum,
            &lt;Const&lt;C1&gt; as ToTypenum&gt;::Typenum,
        &gt;,
    &gt;,
{
    type Output = ArrayStorage&lt;T, R2, C2&gt;;

    fn reshape_generic(self, _: Const&lt;R2&gt;, _: Const&lt;C2&gt;) -&gt; Self::Output {
        unsafe {
            let data: [[T; R2]; C2] = mem::transmute_copy(&amp;self.0);
            mem::forget(self.0);
            ArrayStorage(data)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As these bounds infect the public API, they are also a large backwards compatability concern.</p>
<h3 id="totypenum-is-only-implemented-up-to-fixed-size"><a class="header" href="#totypenum-is-only-implemented-up-to-fixed-size"><code>ToTypenum</code> is only implemented up to fixed size</a></h3>
<p>That's annoying. ✨</p>
<h3 id="cannot-use-associated-constants"><a class="header" href="#cannot-use-associated-constants">Cannot use associated constants</a></h3>
<p>It is currently also not possible to have the size of a matrix depend on associated constants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyDimensions {
   const ROWS: usize;
   const COLS: usize;
}

fn foo&lt;Dims: MyDimensions&gt;() {
    // Not possible!
    let matrix: SMatrix&lt;f64, Dims::ROWS, Dims::COLS&gt; = SMatrix::zeros();
}
<span class="boring">}
</span></code></pre></pre>
<p>While this can be avoided by going to back to <code>typenum</code> and using associated types, this adds a lot of unnecessary bounds and inpacts all of the code dealing with it.</p>
<h3 id="generic-parameters-arent-exhaustive"><a class="header" href="#generic-parameters-arent-exhaustive">Generic parameters aren't exhaustive</a></h3>
<p>Because <code>R</code> and <code>C</code> are generic parameters and not constants, the compiler doesn't know that
<code>DefaultAllocator: Allocator&lt;T, R, C&gt;</code> holds for all <code>R</code> and <code>C</code>, leaking implementation defaults
and causing signatures to be far less readable than necessary.</p>
<h2 id="wishlist"><a class="header" href="#wishlist">Wishlist</a></h2>
<p>Ideally, <code>Matrix</code> could be changed to the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Dim {
    Const(usize),
    Dynamic,
}

struct Matrix&lt;T, const R: Dim, const C: Dim, S&gt; { ... }

type SMatrix&lt;T, const R: usize, const C: usize&gt; =
    Matrix&lt;T, Dim::Const(R), Dim::Const(C), ArrayStorage&lt;T, R, C&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>For this to work well there have a bunch of requirements for const generics:</p>
<h3 id="user-defined-types-as-const-parameter-types"><a class="header" href="#user-defined-types-as-const-parameter-types">User-defined types as const parameter types</a></h3>
<p>We have to be able to use <code>Dim</code> as a const param type</p>
<h3 id="consider-injective-expressions-to-bind-generic-params"><a class="header" href="#consider-injective-expressions-to-bind-generic-params">Consider injective expressions to bind generic params</a></h3>
<p>With this change, <code>nalgebra</code> needs impls like the following</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const R: usize, const C: usize&gt; for SMatrix&lt;T, R, C&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>For this impl to bind <code>R</code> and <code>C</code>, the expression <code>Dim::Const(N)</code> has to bind <code>N</code>.
This is sound as constructors are injective. It seems very desirable to at least
enable this for expressions using constructors.</p>
<p>Without this, one gets an error message like the following:</p>
<pre><code>error[E0207]: the const parameter `R` is not constrained by the impl trait, self type, or predicates
 --&gt; src/lib.rs:5:12
  |
5 | impl&lt;T, const R: usize, const C: usize&gt; for SMatrix&lt;T, R, C&gt; {
  |               ^ unconstrained const parameter
  |
  = note: expressions using a const parameter must map each value to a distinct output value
  = note: only used in the expression `Dim::Const(R)`
  = note: proving the result of expressions other than the parameter are unique is not supported
</code></pre>
<h3 id="merge-partial-impls-to-be-exhaustive"><a class="header" href="#merge-partial-impls-to-be-exhaustive">Merge partial impls to be exhaustive</a></h3>
<p>By adding one trait impl impl for <code>Dim::Dynamic</code> and one for <code>Dim::Const(N)</code>, it should be enough to consider that trait to be implemented for all <code>Dim</code>.</p>
<p>Ideally, the compiler should figure this out by itself, or it can be emulated using specialization by manually adding an impl for all <code>Dim</code> which always gets overridden.</p>
<h3 id="generic-const-expressions"><a class="header" href="#generic-const-expressions">Generic const expressions</a></h3>
<p>For example when computing the <a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a> which has the following simplified signature:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn kronecker&lt;T, const R1: Dim, const C1: Dim, const R2: Dim, const C2: Dim&gt;(
    lhs: &amp;Matrix&lt;T, R1, C2&gt;,
    rhs: &amp;Matrix&lt;T, R2, C2&gt;,
) -&gt; Matrix&lt;T, R1 * R2, C1 * C2&gt; {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>For this generic const expressions have to be supported.</p>
<h3 id="const-trait-implementations"><a class="header" href="#const-trait-implementations">const Trait implementations</a></h3>
<p>For <code>R1 * R2</code> to work we need const trait impls, otherwise this
can be written using <code>mul_dim(R1, R2)</code> or something.</p>
<h2 id="default-for-arrays"><a class="header" href="#default-for-arrays"><code>Default</code> for arrays</a></h2>
<p><code>nalgebra</code> currently has to work around <code>Default</code> not being implemented
for all arrays where <code>T: Default</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-shiny-future-where-we-want-to-get-to"><a class="header" href="#-shiny-future-where-we-want-to-get-to">✨ Shiny future: Where we want to get to</a></h1>
<p>The &quot;shiny future&quot; is here to tell you what we are trying to build over the next 2-3 years. That is, it presents our &quot;best guess&quot; as to what will look like a few years from now. When describing specific features, it also embeds links to <a href="vision/../design_notes.html">design notes</a> that describe the constraints and general plans around that feature.</p>
<p>Predicting the future is a tricky business! Many of the things described in the &quot;shiny future&quot; doc have a lot of uncertainty. We fully expect that the designs and narratives described in this document will change as we work towards realizing them. When there are areas of particular uncertainty, we use the Frequently Asked Questions and the design docs to call them out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-shiny-future-story-barbara-implements-default-for-all-array-lengths"><a class="header" href="#-shiny-future-story-barbara-implements-default-for-all-array-lengths">✨ Shiny future story: Barbara implements <code>Default</code> for all array lengths</a></h1>
<p>Shiny future of <a href="vision/shiny_future/../status_quo/array_default.html">status quo story</a></p>
<p>Barbara is working on <code>std</code>. She saw that the newest version of rustc has had some improvements to const generics
and decides to try implementing <code>Default</code> for all array lengths. She goes to write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; Default for [T; N]
where
    T: Default,
{
    fn default() -&gt; Self {
        /* snip */
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code builds just fine but then she sees a test failing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;() -&gt; [T; 0] {
    Default::default()
}
<span class="boring">}
</span></code></pre></pre>
<p>&quot;Ah,&quot; she says, &quot;I see that Default is implemented for any type [T; 0], regardless of whether T: Default. That makes sense. Argh!&quot;</p>
<p>Next she tries to write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; Default for [T; N]
where
    T: Default,
    { N &gt; 0 },
{
    fn default() -&gt; Self {
        /* snip */
    }
}

impl&lt;T&gt; Default for [T; 0] {
    fn default() -&gt; Self {
        []
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This compiles just fine and the test is passing. She decides to submit a PR where her reviewer asks her to 
add a test to make sure that <code>[T; N]: Default</code> holds when <code>T: Default</code> as this didn't used to work</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exhaustive_default_impl&lt;T: Default, const N: usize&gt;() -&gt; [T; N] {
    &lt;[T; N] as Default&gt;::default()
}
<span class="boring">}
</span></code></pre></pre>
<p>This test passes just fine, &quot;yay const generics ✨&quot; she says</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-shiny-future-story-array-split-first-method"><a class="header" href="#-shiny-future-story-array-split-first-method">✨ Shiny future story: Array split first method</a></h1>
<p>Shiny future of <a href="vision/shiny_future/../status_quo/split_first.html">status quo story</a></p>
<p>Barbara is working on her project. She has the idea to write a <code>split_first</code> function that will allow her to split out the first item from a fixed-length array; naturally, the array must be non-empty. It looks something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: this method has an implied where clause that `N - 1` evaluates without 
// erroring because `N - 1` is in the function signature
fn split_first&lt;T, const N: usize&gt;(arr: [T; N]) -&gt; (T; [T; N - 1]) {
    // ...
    let tail: [T; N - 1] = // ...
    (head, tail)
}
<span class="boring">}
</span></code></pre></pre>
<p>Next she wants to write a function that uses <code>split_first</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_method&lt;const N: usize&gt;(arr: [u8; N]) {
    let (first, rest) = split_first(arr);
    for i in rest {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler gives her a compile error:</p>
<pre><code>error: the constant expression `N - 1` is not known to evaluate without underflowing
2 |     let (first, rest) = split_first(arr);
  |                         ^^^^^^^^^^^ `N - 1` not known to be evaluatable without underflowing
note: required by this expression in `split_first`'s function signature
5 |     fn split_first&lt;T, const N: usize&gt;(arr: [T; N]) -&gt; (T; [T; N - 1]) {
  |                                                               ^^^^^
help: add a where clause to `some_method`
  | fn some_method&lt;const N: usize&gt;(arr: [u8; N]) where { N &gt; 0; }
</code></pre>
<p>Barbara hits the 'quick fix' button in her IDE and it inserts the where clause for her- she immediately
gets a compile error at another spot because she was calling <code>some_method</code> with an empty array:</p>
<pre><code>error: the constant `0` is not greater than `0`
22 |     some_method([])
info: `0` must be greater than `0` because of this where clause
  | fn some_method&lt;const N: usize&gt;(arr: [u8; N]) where { N &gt; 0; }
  |                                                    ----------
</code></pre>
<p>Barbara has no more compile errors, even the following code is compiling:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_other_method&lt;const N: usize&gt;(arr: [u8; N]) where { N &gt; 1; } {
    // ...
    let (first, rest) = split_first(arr);
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-shiny-future-story-image-type-in-rust-gpu"><a class="header" href="#-shiny-future-story-image-type-in-rust-gpu">✨ Shiny future story: Image type in rust-gpu</a></h1>
<p>Barbara is working on rust-gpu. In that project, she has a struct <code>Image</code> that represents GPU images. There are a number of constant parameters allowing this type to be heavily customized in a number of ways. In some cases, helper methods are only available for images with particular formats. She writes the struct declaration:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Image&lt;
    SampledType: SampleType&lt;FORMAT&gt;,
    const DIM: Dimensionality,
    const DEPTH: ImageDepth,
    const ARRAYED: Arrayed,
    const MULTISAMPLED: Multisampled,
    const SAMPLED: Sampled,
    const FORMAT: ImageFormat,
    const ACCESS_QUALIFIER: Option&lt;AccessQualifier&gt;,
&gt;(PhantomData&lt;SampledType&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>Barbara gets a few compile errors about her types used as a const param not implementing <code>StructuralEq</code> so she derives that and moves on.
She then wants to write some methods that only work for images in some specific formats:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;
    SampledType: SampleType&lt;FORMAT&gt;,
    const DIM: Dimensionality,
    const DEPTH: ImageDepth,
    const ARRAYED: Arrayed,
    const MULTISAMPLED: Multisampled,
    const SAMPLED: Sampled,
    const FORMAT: ImageFormat,
    const ACCESS_QUALIFIER: Option&lt;AccessQualifier&gt;,
&gt; Image&lt;SampledType, DIM, DEPTH, ARRAYED, MULTISAMPLED, SAMPLED, FORMAT, ACCESS_QUALIFIER&gt; {
    pub fn example_method(/* snip */)
    where
        { some_condition(DEPTH, MULTISAMPLED) }
    { /* snip */ }
}

const fn some_condition(a: ImageDepth, m: Multisampled) -&gt; bool {
    match (a, m) {
        /* snip */
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This compiles just fine and Barbara moves on to more complicated things </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-the-roadmap-what-were-doing-in-2021"><a class="header" href="#-the-roadmap-what-were-doing-in-2021">📅 The roadmap: what we're doing in 2021</a></h1>
<p>This page describes the current plans for 2021.
It is updated on a monthly basis.</p>
<h2 id="key"><a class="header" href="#key">Key</a></h2>
<table><thead><tr><th>Emoji</th><th>Meaning</th></tr></thead><tbody>
<tr><td>🥬</td><td>&quot;Healthy&quot; -- on track with the plan as described in the doc</td></tr>
<tr><td>✏️</td><td>&quot;Planning&quot; -- Still figuring out the plan</td></tr>
<tr><td>🤒</td><td>&quot;Worried&quot; -- things are looking a bit tricky, plans aren't working out</td></tr>
<tr><td>🏖️</td><td>&quot;On vacation&quot; -- taking a break right now</td></tr>
<tr><td>⚰️</td><td>We gave up on this idea =)</td></tr>
</tbody></table>
<h2 id="roadmap-items"><a class="header" href="#roadmap-items">Roadmap items</a></h2>
<table><thead><tr><th>Plan</th><th>Owner</th><th>Status</th><th>Last updated</th></tr></thead><tbody>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-how-to-vision-doc"><a class="header" href="#-how-to-vision-doc">❓ How to vision doc</a></h1>
<p>This page describes the process for contributing to the vision doc.</p>
<h2 id="who-owns-this-document"><a class="header" href="#who-owns-this-document">Who owns this document?</a></h2>
<p>This document is owned and maintained by the leads of the project-const-generics group.
They decide what content to accept or reject. 
This decision is made in consultation with the Rust teams that will be making the ultimate decisions. 
For example, if a design doc or part of the shiny future is describing a new language feature, the leads ought to  discuss that with the language design team, since that team will ultimately have to approve the RFCs for its design.</p>
<h2 id="how-to-participate"><a class="header" href="#how-to-participate">How to participate</a></h2>
<p>For now, you have to join our weekly meetings.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meetings"><a class="header" href="#meetings">Meetings</a></h1>
<p>This folder contains the minutes of all the recorded meetings that have happened
so far.</p>
<p>Check them out <a href="https://github.com/rust-lang/project-const-generics/tree/master/meetings">on github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-design"><a class="header" href="#-design">📚 Design</a></h1>
<p>For an explanation of how const generics currently works in the compiler,
also check out the <a href="https://rustc-dev-guide.rust-lang.org/constants.html">rustc-dev-guide</a>.</p>
<p>Const generics has quite a few deep rooted issues and design challenges.
In this document we try to highlight some specific topics which are fairly
pervasive while working on this feature.
The goalis to more clearly understand the
current state of const generics and to help us figure out ways to
make progress. Without this the challenges we currently face seem
near insurmountable.</p>
<h3 id="-backwards-compatability"><a class="header" href="#-backwards-compatability">🔙 Backwards compatability</a></h3>
<p>Rust was not design with const generics in mind, and we've also made
some unfortunate decisions even after work on const generics started.</p>
<p>Future extensions of const generics must not cause substantial breakage
to existing code, or if they do, this breakage has to be contained somehow.
A possible solution to many such changes are editions.</p>
<h3 id="-no-perfect-solution"><a class="header" href="#-no-perfect-solution">⚖️ No perfect solution</a></h3>
<p>There isn't just one <em>perfect</em> version of const generics we are working towards.
Instead there are a lot of major and minor tradeoffs between learnability, expressiveness,
implementation complexity and many other factors. As we can't perfectly tell how
const generics will be used in the future, making these decisions can be especially
hard. For any such issues we should try to reach out to the wider community before
coming to a final conclusion.</p>
<h3 id="-the-query-system"><a class="header" href="#-the-query-system">🔄 The query system</a></h3>
<p>Const generics mixes evaluation with typechecking which very quickly reaches the edge
of what is possible with the query system. It might make sense to look at these issues in
unison and consider whether there are some more fundamental changes to the compiler which
provide a better solution to them instead of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.WithOptConstParam.html">adding more hacks</a>.</p>
<h3 id="-optional-extensions"><a class="header" href="#-optional-extensions">❔ Optional extensions</a></h3>
<p>There are a lot of things which are nice to have but not strictly necessary or maybe not even
desirable. This means that decisions which prevents them may still be the correct ones,
i.e. these are not strictly a blocking concern.
We should still try to find alternatives before blocking these though.</p>
<h2 id="const-parameter-types-adt_const_params"><a class="header" href="#const-parameter-types-adt_const_params">Const parameter types (<a href="https://github.com/rust-lang/rust/issues/95174"><code>adt_const_params</code></a>)</a></h2>
<p>On stable, only integers, <code>bool</code>, and <code>char</code> is allowed as the type of const parameters.
We want to extend this to more types in the future.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NamedType&lt;const NAME: &amp;'static str&gt; { ... }
<span class="boring">}
</span></code></pre></pre>
<p>Additionally, we want to support generic const parameter types and must not stabilize anything
which prevents the addition of that in the future.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WithGenericArray&lt;T, const N: usize, const ARRAY: [T; N]&gt; { ... }
<span class="boring">}
</span></code></pre></pre>
<p>This feature interacts with the following topics:</p>
<ul>
<li><a href="design/./constraining-generic-parameters.html">❗ Constraining generic parameters</a></li>
<li><a href="design/./structural-equality.html">❗🔙 ⚖️ Structural equality</a></li>
<li><a href="design/./valid-const-parameter-types.html">❗⚖️ Valid const parameter types</a></li>
<li><a href="design/./valtrees.html">❗ Valtrees</a></li>
<li><a href="design/./generic-const-param-types.html">❗⚖️🔄 Generic const parameter types</a></li>
<li><a href="design/./design/exhaustiveness.html">❔ Exhaustiveness</a></li>
<li><a href="design/./functions-as-const-parameters.html">❔🔙 Functions as const parameters</a></li>
</ul>
<h2 id="generic-constants-in-the-type-system-generic_const_exprs"><a class="header" href="#generic-constants-in-the-type-system-generic_const_exprs">Generic constants in the type system (<a href="https://github.com/rust-lang/rust/issues/76560"><code>generic_const_exprs</code></a>)</a></h2>
<ul>
<li><a href="design/./unused-substs.html">❗🔙 🔄 Unused substs</a></li>
<li>❗ Anonymous constants in binders</li>
<li><a href="design/./eval-errors-during-selection.html">❗🔄 Silence evaluation errors during selection</a></li>
<li>❗🔄 Self referential where clauses</li>
<li>❗🔄 Evaluation without first checking where-clauses</li>
<li>❔ Partially evaluating anonymous constants</li>
</ul>
<h3 id="unifying-generic-constants"><a class="header" href="#unifying-generic-constants">Unifying generic constants</a></h3>
<ul>
<li><a href="design/./const-eval-requirements.html">❗🔙 Restrictions on const evaluation</a></li>
<li><a href="design/./leaking-implementation-details.html">❗🔙 Leaking implementation details</a></li>
<li><a href="design/./opaque-and-transparent-assoc-consts.html">❗🔙 Opaque and transparent associated constants</a></li>
<li>❗ Splitting constants during unification</li>
<li><a href="design/./constraining-generic-parameters.html">❗ Constraining generic parameters</a></li>
<li>❔⚖️ Extending unification logic</li>
</ul>
<h3 id="-const-evaluatable-bounds"><a class="header" href="#-const-evaluatable-bounds">❔ Const evaluatable bounds</a></h3>
<ul>
<li>❗ Using subtrees to fulfill bounds</li>
<li>❔ Discarding bounds and soundness</li>
<li>❔ Compile time conditionals</li>
<li>❔⚖️ Improving const evaluatability checks</li>
</ul>
<p>ALL OF THIS</p>
<h2 id="repeat-length-backcompatability-lint-const_evaluatable_unchecked"><a class="header" href="#repeat-length-backcompatability-lint-const_evaluatable_unchecked">Repeat length backcompatability lint (<a href="https://github.com/rust-lang/rust/issues/76200"><code>const_evaluatable_unchecked</code></a>)</a></h2>
<p>close this or wait until it's possible on stable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-constraining-generic-parameters"><a class="header" href="#-constraining-generic-parameters">❗ Constraining generic parameters</a></h1>
<p>Given an impl, the compiler has to be able to decide the generic arguments used by that impl.
Consider the following snippet:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Weird&lt;const N: usize&gt;;

impl&lt;const A: usize, const B: usize&gt; Weird&lt;{ A + B }&gt; {
    fn returns_a() -&gt; usize {
        A
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When calling <code>Weird::&lt;3&gt;::returns_a()</code>, there is no way to restrict the generic parameters <code>A</code> or <code>B</code> so this has to error.
If a generic parameter is used by an injective expression, then we should allow this. The most relevant case here are
constructors:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UsesOption&lt;const N: Option&lt;usize&gt;&gt;;
impl&lt;const N: usize&gt; UsesOption&lt;{ Some(N) }&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>Here it is very clear which <code>N</code> we should use given <code>UsesOption::&lt;{ Some(3) }&gt;</code>.</p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p><strong>Blocked</strong>: Before making any decisions here we should first figure out <a href="design/./design/structural-equality.html">structural equality</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-generic-const-parameter-types"><a class="header" href="#-generic-const-parameter-types">❗⚖️🔄 Generic const parameter types</a></h1>
<p>We want to support the types of const parameters
to depend on other generic parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const LEN: usize, const ARR: [u8; LEN]&gt;() -&gt; [u8; LEN] {
    ARR
}
<span class="boring">}
</span></code></pre></pre>
<p>This is currently forbidden during name resolution.</p>
<p>Probably the biggest blocker is type-checking const arguments
for generic parameters. This currently uses <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.WithOptConstParam.html">a hack</a>
to supply the <code>DefId</code> of the corresponding const parameter.</p>
<p>Now, let's look at the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: usize, const M: [u8; N]&gt;() {}

fn bar() {
    foo::&lt;3, { [0; 3] }&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the expected type of <code>{ [0; 3] }</code> should be <code>[u8; 3]</code>. With the
current approach it is <code>[u8; N]</code> instead. To fix this we would have to
supply the affected queries the expected type of the const argument itself
or use a <code>(DefId, SubstsRef&lt;'tcx&gt;)</code> pair instead.</p>
<p>Doing so isn't trivial because we have to worry about accidentially
ending up with different types for the same const argument which would
break stuff. </p>
<p>Potential dangers include partially resolved types and projections.</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p><strong>Blocked</strong>: We should first stabilize <code>feature(adt_const_params)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-leaking-implementation-details"><a class="header" href="#-leaking-implementation-details">❗🔙 Leaking implementation details</a></h1>
<p>When unifying generic constants, we have to avoid accidentally stabilizing
parts of our lowering.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const B: bool&gt;() -&gt; [u8; if B { 3 } else { 7 }] {
    [0; match B {
        true =&gt; 3,
        false =&gt; 7,
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>If we allow <code>foo</code> to compile, we have to guarantee that we will continue supporting it
in the future. While this is fine if we intentionally allow it, it could also be allowed
by accident if we we use the same representation for <code>if</code> and <code>match</code> in the abstract representation for
generic constants.</p>
<p>Another issue here is the removal of noops, like redundant <code>as</code>-casts. This was an issue with a
previous implementation which relied on the MIR of generic constants for unification.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn multiple_casts&lt;const N: u8&gt;() -&gt; [u8; N as usize as usize] {
    [0; N as usize]
}
<span class="boring">}
</span></code></pre></pre>
<p>In general, the unification of generic constants has to add a new representation for expressions which can
be used in types. If we end up stabilizing <code>feature(generic_const_exprs)</code> with a suboptimal lifting from expressions
to that new representation, this will probably be quite difficult to fix while maintaining backwards compatability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-opaque-and-transparent-associated-constants"><a class="header" href="#-opaque-and-transparent-associated-constants">❗🔙 Opaque and transparent associated constants</a></h1>
<p>As we want to be able to use associated constants in types, we have to look into them for unification.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Encode {
    const LENGTH: usize;
    fn encode(&amp;self) -&gt; [u8; Self::LENGTH];
}

struct Dummy&lt;const N: usize&gt;;
impl&lt;const N: usize&gt; for Dummy&lt;N&gt; {
    const LENGTH: usize = N + 1;
    fn encode(&amp;self) -&gt; [u8; Self::LENGTH] {
        [0; N + 1]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For this to compile, we have to unify <code>Self::LENGTH</code> with <code>N + 1</code>. That means that we have to look into
this associated constant, i.e. we have to treat it as transparent.</p>
<p>Treating all associated constants causes some concerns however.</p>
<h4 id="additional-stability-requirements"><a class="header" href="#additional-stability-requirements">Additional stability requirements</a></h4>
<p>Consider a library which has a public associated constant</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::size_of;
trait WithAssoc {
    const ASSOC: usize;
}

struct MyType&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; WithAssoc for MyType&lt;T&gt; {
    const ASSOC: usize = size_of::&lt;Vec&lt;T&gt;&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>In a new minor version, they've cleaned up their code and changed the associated constant to <code>size_of::&lt;Self&gt;()</code>.
Without transparent associated constant, this can't break anything. If <code>ASSOC</code> is treated transparently,
this change is now theoretically breaking. </p>
<h4 id="overly-complex-associated-constants"><a class="header" href="#overly-complex-associated-constants">Overly complex associated constants</a></h4>
<p>Our abstract representation used during unification will not be able to represent arbitrary user code.
This means that there will be some - potentially already existing - associated constants we cannot convert
to this abstract representation.</p>
<p>It is unclear how much code is affected by this and what the right solution for this would be.
We should probably either silently keep these associated constants opaque or keep them opaque and emit a warning.</p>
<h3 id="keeping-some-associated-constants-opaque"><a class="header" href="#keeping-some-associated-constants-opaque">Keeping some associated constants opaque</a></h3>
<p>Still undecided how this should be handled. We can make transparent constants opt-in, potentially making associated constants
used in some other type of the trait impl transparent by default. We could also make constants transparent by default
and keep constants for which the conversion failed opaque, either emitting a warning or just silently.</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p><strong>Blocked</strong>: We should wait for <code>feature(generic_const_exprs)</code> to be closer to stable before thinking about this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-restrictions-on-const-evaluation"><a class="header" href="#-restrictions-on-const-evaluation">❗🔙 Restrictions on const evaluation</a></h1>
<p>For generic constants in the type system to be sound, const evaluation must
not be able to differentiate between values considered equal by the type system.
Const evaluation must also be fully deterministic and must not depend on any external state
when used in the type system.</p>
<h2 id="floats"><a class="header" href="#floats">Floats</a></h2>
<p>Using floats during CTFE is fully determinstic. So using
them inside of the type system is fine. CTFE can however
produce different results than what would happen on real hardware,
but this is not a concern for const generics.</p>
<h2 id="dealing-with-references-and-allocations"><a class="header" href="#dealing-with-references-and-allocations">Dealing with references and allocations</a></h2>
<p>Other sources of non-determinism are allocations. This non-determinism
must however not be observed during const-evaluation (TODO: link to const-eval).</p>
<p>Any references used in a constant are considered equal if their targets are equal, which is also determistic.
This is needed by <a href="design/./valtrees.html">valtrees</a>. The specific design of valtrees also adds some other
additional constraints to const evaluation which are listed on its page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-silence-evaluation-errors-during-selection"><a class="header" href="#-silence-evaluation-errors-during-selection">❗🔄 Silence evaluation errors during selection</a></h1>
<p>Given an impl like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait&lt;const N: usize&gt; {
    type Assoc;
}
impl&lt;const N: usize&gt; Trait&lt;N&gt; for [u8; N - 1] {
    type Assoc = u32;
}
impl&lt;const N: usize&gt; Trait&lt;0&gt; for [u8; 0] {
    type Assoc = u64;
}
<span class="boring">}
</span></code></pre></pre>
<p>This would cause an error during coherence because we fail to evaluate <code>N - 1</code> when using <code>0</code> for <code>N</code>.</p>
<h3 id="can-we-avoid-silent-ctfe-errors"><a class="header" href="#can-we-avoid-silent-ctfe-errors">Can we avoid silent CTFE errors?</a></h3>
<p><strong>tl;dr: no</strong></p>
<p>Changing CTFE to potentially not emit errors is not ideal and could be a new source of bugs.
Everything else being equal, we should avoid this.</p>
<p>Instead of using const evaluation failures to discard candidates, we could instead use conditions,
rewriting the above example to</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Condition&lt;const B: bool&gt;;
trait IsTrue {}
impl IsTrue for Condition&lt;true&gt; {}

trait Trait&lt;const N: usize&gt; {
    type Assoc;
}
impl&lt;const N: usize&gt; Trait&lt;N&gt; for [u8; N - 1]
where
    Condition&lt;{ N &gt; 0 }: IsTrue,
{
    type Assoc = u32;
}
impl&lt;const N: usize&gt; Trait&lt;0&gt; for [u8; 0] {
    type Assoc = u64;
}
<span class="boring">}
</span></code></pre></pre>
<p>This would make it difficult for the compiler to check that these impls are <a href="design/./exhaustiveness.html">exhaustive</a>
if that is something we want to add. <strong>TODO: this isn't necessarily true, elaborate here</strong></p>
<p>It also might not even be enough to avoid incorrect errors during candidate selection.
We start candidate selection by trying to unify the the <code>TraitRef</code>s of the impl and the obligation.
Checking whether <code>[u8; 0]: Trait&lt;N&gt;</code> holds therefore tries to unify <code>[u8; ?0 - 1]: Trait&lt;?0&gt;</code> with <code>[u8; 0]: Trait&lt;0&gt;</code>
which - unless we explicitly avoid it - will cause us to evaluate <code>0 - 1</code> and emit an error. </p>
<p>This issue is also prevalent for generic constants in <code>where</code>-clauses.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}
impl&lt;const N: usize&gt; Foo for [u8; N]
where
    Condition&lt;{ N &gt; 0 }&gt;: IsTrue,
    [u8; N - 1]: Foo,
{}
<span class="boring">}
</span></code></pre></pre>
<p>We would have to somehow force the compiler to first check <code>Condition&lt;{ N &gt; 0 }&gt;: IsTrue</code> before checking <code>[u8; N - 1]: Foo</code>.
While we could add some special predicate kind for &quot;this has to evaluate to <code>true</code>&quot;, we still have the same issue in case
we have multiple such bounds which some dependencies between them. Another option would be to check predicates in a defined order,
e.g. in order of appearance. That is difficult to fit into the current query system and opens up a lot of difficult questions.</p>
<p><strong>TODO</strong>: Refer to cyclic dependencies in where clauses here, that would also theoreticall be solved by relying on a syntactic order
and should go more in-depth than this.</p>
<p>We therefore believe that the option for CTFE errors to be silent is needed.</p>
<h3 id="undefined-behavior-during-ctfe"><a class="header" href="#undefined-behavior-during-ctfe">Undefined behavior during CTFE</a></h3>
<p>Whether the compiler detects undefined behavior during const evaluation is not part
of our stability guarantees, so we <strong>must not</strong> consider some candidate to not apply due to UB by itself.</p>
<p>We can therefore either only error if the impl would apply unless UB were to occur or always emit an error.
Always emitting an error when encountering UB seems desirable, even if it happens during selection.</p>
<h3 id="reaching-const_eval_limit"><a class="header" href="#reaching-const_eval_limit">Reaching <code>#[const_eval_limit]</code></a></h3>
<p>When reaching the interpreter step limit, e.g. by using <code>loop {}</code>, it is unclear whether the code
would compile after some additional steps. We therefore have to treat this in the same way as UB.
Unlike UB, rejecting a candidate because the <code>#[const_eval_limit]</code> is reached would even be unsound,
as a different crate could raise that limit and would therefore consider the candidate to hold.</p>
<h3 id="possible-designs"><a class="header" href="#possible-designs">Possible designs</a></h3>
<p>We're going to refer to the initial example of this document.</p>
<h4 id="rely-on-errors-for-disjointness"><a class="header" href="#rely-on-errors-for-disjointness">Rely on errors for disjointness</a></h4>
<p>Do we want to consider impls for <code>[u8; N - 1]</code> and <code>[u8; 0]</code> to be disjoint by themselves?</p>
<p>Given that we have to silence the CTFE errors anyways, we could reject candidates if they contain a constant which fails to evaluate.
If we do this, the following change can break code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// original version:
const fn my_computation(n: usize) -&gt; usize {
    if some_edge_case(n) {
        unimplemented!()
    } else {
        whatever(n)
    }
}
// updated version:
const fn my_computation(n: usize) -&gt; usize {
    if some_edge_case(n) {
        deal_with_edge_case(n)
    } else {
        whatever(n)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>It generally seems desirable to not consider such a change to be breaking. Such a case actually causing issues seems quite unlikely,
though it definitely may happen that people write overlapping impls relying on <code>some_edge_case</code> precisely because <code>my_computation</code> panics in
that case.</p>
<h4 id="require-explicit-bounds"><a class="header" href="#require-explicit-bounds">Require explicit bounds</a></h4>
<p>We could also require a <code>Condition&lt;{ N &gt; 0 }&gt;: IsTrue</code> bound for this to compile,
potentially adding some syntactic sugar or special predicate for this.</p>
<p>This adds some additional boilerplate to impls, though it does reduce the
amount of implicit behavior the user has to understand. It also prevents any unintentional breakage
when fixing buggy functions which would cause them to terminate successfully instead of panicking.
For types like <code>[u8; N / 2 - 1]</code> the correct boolean condition to prevent this from panicking isn't immediately obvious however.
This could introduce some errors. To avoid these we could add a lint, recommending the correct boolean condition for a given computation where possible.</p>
<p>If a candidate contains a CTFE failure but would otherwise hold, we can either consider that candidate to be ambiguous or emit a hard
error. The exact impact of making candidates ambiguous isn't yet clear and needs further consideration.</p>
<h4 id="require-explicit-bounds-for-ctfe-failures-inside-of-functions"><a class="header" href="#require-explicit-bounds-for-ctfe-failures-inside-of-functions">Require explicit bounds for CTFE failures inside of functions</a></h4>
<p>Changing the body of a constant used in the type system will be a breaking change as it may can prevent unification.
It might therefore be sensible that errors originating directly in the anonymous constant - or transparent named constant - 
cause the candidate to be rejected while errors originating in functions - or opaque named constants - would require an explicit bound.</p>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p><strong>Idle</strong>: We can already work on this but it's also fine to wait until <code>feature(generic_const_exprs)</code> is
closer to stable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--structural-equality"><a class="header" href="#--structural-equality">❗🔙 ⚖️ Structural equality</a></h1>
<p>We have to figure out which values and types can be sensibly compared at compile time.</p>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p><strong>In progress</strong>: <a href="https://github.com/lcnr/">lcnr</a> is working on this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--unused-substs"><a class="header" href="#--unused-substs">❗🔙 🔄 Unused substs</a></h1>
<p>This is one of the core issues wrt generic constants in the type system.
With <code>feature(generic_const_exprs)</code> we would like <code>foo::&lt;{ N + 3 }&gt;</code> to be valid code.
The current implementation gives anonymous constants all of the generics and where clauses of the parent item:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;const N: usize, T: Trait&gt;() {
    foo::&lt;{ N + 1 }&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>is desugared to</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;const N: usize, T: Trait&gt;() {
    const ANON_CONST&lt;const N: usize, T: Trait&gt;: usize = N + 1;
    foo::&lt;ANON_CONST::&lt;N, T&gt;&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>This causes a lot of issues.</p>
<h4 id="forcing-all-type-parameters-to-be-invariant"><a class="header" href="#forcing-all-type-parameters-to-be-invariant">Forcing all type parameters to be invariant</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T, const N: usize&gt; {
    field: [u8; N + 1],
    by_ref: &amp;'a T,
}
<span class="boring">}
</span></code></pre></pre>
<p>is desugared to</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ANON_CONST&lt;'a, T, const N: usize&gt;: usize = N + 1;
struct Foo&lt;'a, T, const N: usize&gt; {
    field: [u8; ANON_CONST::&lt;'a, T, N&gt;],
    by_ref: &amp;'a T,
}
<span class="boring">}
</span></code></pre></pre>
<p>Generic arguments of anonymous constants are forced to be invariant. This
causes <code>'a</code> and <code>T</code> be invariant even though they aren't actually used.</p>
<h4 id="unsize-coercions-78369"><a class="header" href="#unsize-coercions-78369">Unsize coercions (<a href="https://github.com/rust-lang/rust/issues/78369">#78369</a>)</a></h4>
<pre><pre class="playground"><code class="language-rust">struct P&lt;T: ?Sized&gt;([u8; 1 + 4], T);

fn main() {
    let x: Box&lt;P&lt;[u8; 0]&gt;&gt; = Box::new(P(Default::default(), [0; 0]));
    let _: Box&lt;P&lt;[u8]&gt;&gt; = x;
}
</code></pre></pre>
<p>This compiles on stable but fails to compile if we provide <code>T</code> to the anonymous constant <code>1 + 4</code> as
we now cannot unsize <code>T</code> anymore.</p>
<h4 id="self-referential-closures-85665"><a class="header" href="#self-referential-closures-85665">Self referential closures (<a href="https://github.com/rust-lang/rust/issues/85665">#85665</a>)</a></h4>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;F: FnOnce([u8; N - 1]), const N: usize&gt;(_: F) {}

fn main() {
    foo(|arg: [u8; 5]| ());
}
</code></pre></pre>
<p>The anonymous constant <code>N - 1</code> has <code>F</code> as a generic parameter. This means that the function signature of <code>F</code> contains
<code>F</code> itself, causing an error.</p>
<h2 id="how-this-might-get-fixed"><a class="header" href="#how-this-might-get-fixed">How this might get fixed</a></h2>
<p>As this is one of the core issues of const generics, we thought about quite a few potential solutions to this issue.</p>
<h3 id="completely-replacing-tyconstkindunevaluated"><a class="header" href="#completely-replacing-tyconstkindunevaluated">Completely replacing <code>ty::ConstKind::Unevaluated</code></a></h3>
<p>By never representing anonymous constants as <code>ty::ConstKind::Unevaluated</code> and instead directly converting them into some abstract
representation, we can avoid these issues, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F: FnOnce([u8; N - 1]), const N: usize&gt;(_: F) {}
// We could represent `N - 1` as `ty::ConstKind::Expr(ty::Expr::Sub(N, 1))`,
// meaning that we don't mention `F` at all.
<span class="boring">}
</span></code></pre></pre>
<p>This means we directly embed the fully expanded <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/traits/const_evaluatable/struct.AbstractConst.html">AbstractConst</a> directly as a variant of <code>ty::ConstKind</code>.</p>
<ul>
<li>this has to happen incredibly early, can't really use typeck to get the abstract representation, add some special &quot;mini typeck&quot; which
directly converts <code>hir</code> into the <code>ty::ConstKind::Expr</code> representation.
<ul>
<li>what if that mini typeck disagrees with the &quot;correct typeck&quot;</li>
<li>do we still want to typeck anon consts or do we only use the &quot;mini typeck&quot;</li>
<li>the &quot;mini typeck&quot; will only allow a fairly arbitrary and small subset
<ul>
<li>the more we allow, the higher our maintenance</li>
<li>will be fairly untested, so there could be a lot of bugs and bad diagnostics here</li>
<li>though, even when not using the mini typeck, we still have to restrict expressions which can
be used in generic anonymous constants</li>
</ul>
</li>
<li>the &quot;mini typeck&quot; can't be used for concrete anonymous constants
<ul>
<li>constants which don't explicitly mention a generic param keep getting typechecked without any generics in scope.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-valid-const-parameter-types"><a class="header" href="#-valid-const-parameter-types">❗⚖️ Valid const parameter types</a></h1>
<p><strong><a href="https://github.com/rust-lang/project-const-generics/issues/6">project-const-generics#6</a></strong></p>
<p>We have to decide which types may be used as a const parameter and whether there needs to be explicit opt-in.</p>
<h2 id="status-4"><a class="header" href="#status-4">Status</a></h2>
<p><strong>Blocked</strong>: Waiting on <a href="design/./structural-equality.html">structural equality</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-valtrees"><a class="header" href="#-valtrees">❗ Valtrees</a></h1>
<p>A new representation for <code>ty::Const</code>.</p>
<h2 id="-figure-out-how-they-interact-with-references-wrt-padding"><a class="header" href="#-figure-out-how-they-interact-with-references-wrt-padding">❗ Figure out how they interact with references wrt padding</a></h2>
<p><strong><a href="https://github.com/rust-lang/project-const-generics/issues/20">project-const-generics#20</a></strong></p>
<h2 id="status-5"><a class="header" href="#status-5">Status</a></h2>
<p><strong>In Progress</strong>: <a href="https://github.com/rust-lang/project-const-generics/issues/20">b-naber</a> is working on this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-exhaustiveness"><a class="header" href="#-exhaustiveness">❔ Exhaustiveness</a></h1>
<p>Whether we want to be able to unify different partial impls to consider them exhaustive.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ForBool&lt;const B: bool&gt; {}

impl ForBool&lt;true&gt; for u8 {}
impl ForBool&lt;false&gt; for u8 {}
// Does `for&lt;const B: bool&gt; u8: ForBool&lt;B&gt;` hold?
<span class="boring">}
</span></code></pre></pre>
<h2 id="status-6"><a class="header" href="#status-6">Status</a></h2>
<p><strong>Idle</strong>: While not blocked, it may make sense to wait until we are able to <a href="design/./constraining-generic-parameters.html">constrain generic parameters</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-functions-as-const-parameters"><a class="header" href="#-functions-as-const-parameters">❔🔙 Functions as const parameters</a></h1>
<p><strong><a href="https://github.com/rust-lang/project-const-generics/issues/7">project-const-generics#7</a></strong></p>
<p>It would be nice to allow function pointers as const parameter types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: fn() -&gt; usize&gt;() {}
<span class="boring">}
</span></code></pre></pre>
<p>While they do have a sensible definition of structural equality at compile time,
comparing them is not deterministic at runtime. This behavior might be fairly surprising,
so it might be better to not allow this.</p>
<h2 id="current-status-1"><a class="header" href="#current-status-1">Current status</a></h2>
<p><strong>Planning/Blocked</strong>: needs <code>generic_const_exprs</code> to be closer to stable before it makes sense to start working on this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rfc-drafts"><a class="header" href="#-rfc-drafts">✏️ RFC drafts</a></h1>
<p>This folder contains drafts of RFCs that the group is preparing to submit.</p>
<!--
Once the group has submitted RFCs, the drafts should be deleted from this folder,
and links to the pull requests on the RFC repository should be listed here.
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="viz.js"></script>
        <script type="text/javascript" src="panzoom.min.js"></script>
        <script type="text/javascript" src="full.render.js"></script>
        <script type="text/javascript" src="skill-tree.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
